# 进程创建
## fork
进程调用fork，当控制转移到内核中的fork代码后，内核做：
> * 分配新的**内存块**和**核心数据结构**给子进程
> <u>(**进程PCB**，**进程地址空间**，**页表**，**构建映射关系**)</u>
> * 将父进程部分数据结构内容<u>拷贝</u>至子进程
> * 添加子进程到**系统列表**当中
> * fork返回后，开始调度器调度

### 写时拷贝
![在这里插入图片描述](E:/Typora%E4%BA%91%E7%AC%94%E8%AE%B0%E6%9C%AC/picture/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pe256m65peF5a6i772e,size_20,color_FFFFFF,t_70,g_se,x_16.png)
页表中需要有2^32个地址需要映射，如果页表每一部分6字节
则一共需要24GB
> 缺页中断：父子当中突然改变了数据，OS就发生了中断，但是之前那个空间是共享的，OS就开辟了一个空间，把老的空间给拷过来，OS重新修改了页表，映射关系，把只读选项给去掉了，保持进程的独立性
> 有了写时拷贝，就能保证父子进程数据的独立性

# 进程终止
把进程开辟的东西都释放掉
## 进程退出场景
> 1. 代码运行完毕，结果是正确的
> 2. 代码运行完毕，结果是错误的 
> 3. 代码异常中止

~~~c
return 0；
~~~
* 为什么main函数要return 0，意义在哪里？
> 进程的退出码，衡量代码跑完了，是对还是不对，
> return 0代表success
> return 100
> ![在这里插入图片描述](E:/Typora%E4%BA%91%E7%AC%94%E8%AE%B0%E6%9C%AC/picture/a892988c1c16488fb41e33d9f131741a.png)


## 进程常见退出方法