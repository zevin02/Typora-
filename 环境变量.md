# 进程的相关概念

* **竞争性**：系统进程数目众多，而CPU 资源只有少量，甚至1个，所以进程之间具有竞争属性，为了高效的完成任务，就有了优先级
* **独立性**：进程本身具有独立性，打开如何软件其他软件都不会受影响，需要独享资源，多个进程之间互不干扰
* **并行**：<u>多个进程再多个CPU</u> 下分别，同时运行
* **并发**：<u>多个进程在一个CPU</u> 下采用切换的方式，在一个时间段，多个进程都得以推进

# 环境变量

~~~cpp
  1 #include<stdio.h>
  2 #include<unistd.h>
  3 int main()
  4 {
  5   int cnt=5;
  6   while(cnt--)
  7   {
  8   ¦// printf("I am a process ,pid %d,ppid %d\n",getpid(),getppid());
  9   ¦ sleep(1);
 10   ¦ printf("I am a cmd -->process\n");
 11                                                                                                                    
 12   }
 13   return 0;
 14 }
~

~~~

![image-20220314173414178](E:/Typora%E4%BA%91%E7%AC%94%E8%AE%B0%E6%9C%AC/picture/image-20220314173414178.png)



> 这些命令，程序工……本质上都是可执行的文件
>
> 那么我们运行的时候，为何要<u>./???</u>



> ./可以帮助系统确认对应的程序在哪里
>
> 那么为什么系统的命令不需要带路径呢？
>
> > 就是因为有环境变量



## 常见的环境变量

* PATH ：指定命令的搜索路径



echo $PATH

显示某个环境变量值，在这个环境变量里面的可执行文件就可以直接运行执行



![image-20220314174401020](E:/Typora%E4%BA%91%E7%AC%94%E8%AE%B0%E6%9C%AC/picture/image-20220314174401020.png)

export

**添加设置一个新的环境变量**，这样我们自己写的myproc就可以直接运行了

![image-20220314175025500](E:/Typora%E4%BA%91%E7%AC%94%E8%AE%B0%E6%9C%AC/picture/image-20220314175025500.png)



![image-20220316125037741](E:/Typora%E4%BA%91%E7%AC%94%E8%AE%B0%E6%9C%AC/picture/image-20220316125037741.png)

将本地变量导成环境变量

* set

  显示本地定义的shell命令和环境变量

* unset

  清除环境变量

  ![image-20220316125511247](E:/Typora%E4%BA%91%E7%AC%94%E8%AE%B0%E6%9C%AC/picture/image-20220316125511247.png)

* HOME 

  指定用户的主目录

![image-20220314180102549](E:/Typora%E4%BA%91%E7%AC%94%E8%AE%B0%E6%9C%AC/picture/image-20220314180102549.png)



* env



显示所有的环境变量



![image-20220314180401494](E:/Typora%E4%BA%91%E7%AC%94%E8%AE%B0%E6%9C%AC/picture/image-20220314180401494.png)



* echo 显示某个环境变量的值

  



语言上面定义变量：本质上是在内存中开辟一个空间

> 环境变量本质上，**OS** 在**内存/磁盘文件**中**给自己开辟的空间**，用来**保存系统相关的数据**



环境变量

：变量名+变量内容（a，10）



系统上还有一种变量，是与本次登录有关的变量，只在本次登录有效，叫做本地变量







以空格为分隔符，每个都看作字符串，argv[0]=当前目录，程序的名字，最后一个元素指向NULL

argc决定有几个有效的元素



![image-20220316130008181](E:/Typora%E4%BA%91%E7%AC%94%E8%AE%B0%E6%9C%AC/picture/image-20220316130008181.png)



## 获得环境变量

~~~cpp
 1 #include<stdio.h>
  2 #include<unistd.h>
  3 int main(int argc ,char* argv[],char *env[])//可以获得环境变量的字符串数组，和argv相类似
  4   //argv是一个字符串数组，有argc个变量
  5 {
  6   int j=0;
  7   for(j=0;env[j];j++)//这个是系统自动给我们添加的，所以不带数字的参数
  8   {                                                                                                                                                                                              
  9   ? printf("%s ",env[j]);//因为最后一个数据是NULL
 10   }
 11   int i=0;
 12   for(i=0;i<argc;i++)
 13   {
 14   ? printf("argv[%d]=%s\n",i,argv[i]);
 15   }
 16 //  int cnt=5;
 17 //  while(cnt--)
 18 //  {
 19 //   // printf("I am a process ,pid %d,ppid %d\n",getpid(),getppid());
 20 //    sleep(1);                                                                                                  
 21 //    printf("I am a cmd -->process\n");                 
 22 //                                                                
 23 //  }             
 24   return 0;                                         
 25 } 
~~~



函数如果没有参数，可以传参吗

> 是可以的，只不过获取数据的参数



常见的获得环境变量的方式



getenv（char *name）

~~~c
#include<stdio.h>
#include<stdlib.h>

int main()
{
    printf("PATH: %s ",getenv("PATH"));//获得PATH 的环境变量
    
return 0;
}

~~~

但是我们也很少获取环境变量

